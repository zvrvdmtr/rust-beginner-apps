## TCP server using libc

### Этапы создание сервера
По сути создание сервера и его запуск сводится к последовательному вызову нескольких syscall. 
#### socket
##### Создаем сокет
Создаем сокет через системный вызов [socket(2)](https://man7.org/linux/man-pages/man2/socket.2.html).
При создании надо определиться с тем, какой именно сокет нужен. Так как мы пишем TCP-сервер, то нам нужен AF_INET домен, который умеет работать с [IP(7)](https://man7.org/linux/man-pages/man7/ip.
Параметры передаваемые в функцию:
1. domain - тип коммуникации создаваемого сокета. AF_INET - стек протоколов IPv4 7.html)
2. type - тип сокета. SOCK_STREAM - сокет устанавливает соединение между сервером и клиентом
3. protocol - определяет конкретный протокол. По умолчания 0 для SOCK_STREAM это TCP протокол.

##### Как проверить
1. Находим PID процесса по его названию `PROC=$(pgrep raw-socket)`
2. Ищем файловый дескриптор через привязанный к этому PID
```
~ lsof -i -P | grep $PROC`
raw-socke 12281       d.zverev    3u  IPv4  0x4e5a4388b3ded2c      0t0    TCP *:* (CLOSED)
```
Можно обратить внимание, что статус сокета CLOSED.

#### bind
##### Привязываем сокет к интерфейсу и порту
Для того, что бы забиндить сокет к какому-то конкретному адресу (интерфейс:порт) нужно использовать сигнал [bind(2)](https://man7.org/linux/man-pages/man2/bind.2.html).
Параметры передаваемые в функцию:
1. Файловый дескриптор
2. Заполняем контейнер для адреса сокета [sockaddr(3type)](https://man7.org/linux/man-pages/man3/sockaddr.3type.html)
3. Размер передаваемой структуры из второго аргумента

##### Как проверить
1. Находим PID процесса по его названию `PROC=$(pgrep raw-socket)`
2. Ищем файловый дескриптор через привязанный к этому PID
```
~ lsof -i -P | grep $PROC`
raw-socke 83631       d.zverev    3u  IPv4 0xb3554c101dc7e94c      0t0    TCP *:8080 (CLOSED)
```
Статус сокета все еще CLOSED, но уже появился порт.

#### listen
##### Делаем сокет пассивным и ждем входящих соединений
Что бы сокет начал принимать соединения его необходимо сделать пассивным, используя системный вызов [listen(2)](https://man7.org/linux/man-pages/man2/listen.2.html).
Параметры передаваемые в функцию:
1. Файловый дескриптор
2. Количество соединений, которые сокет может добавить в очередь ожидания (очередь тех кто не прошел рукопожатие). Лишние соединения буду сброшены.
Давайте установим количество соединений в районе 5, в будущем поэкспериментируем с ними.

##### Как проверить
```
~ lsof -i -P | grep $PROC`
raw-socke 87456       d.zverev    3u  IPv4 0x4d2c0f5d32067c00      0t0    TCP *:8080 (LISTEN)
```
А вот теперь сокет переходит в состояние LISTEN

#### accept
##### Принимаем входящее соединение
Все соединения, которые запрашивают наш сервер делятся на 2 типа: тех кто прошел рукопожатие и тех кто нет.
Для каждого типа соединения существует своя очередь.
Системный вызов [accept(2)](https://man7.org/linux/man-pages/man2/accept.2.html) берет первое соединение из очереди, где находятся соединения которые прошли рукопожатие, и создает новый сокет.
Параметры передаваемые в функцию:
1. Файловый дескриптор
2. Заполняем контейнер для адреса сокета [sockaddr(3type)](https://man7.org/linux/man-pages/man3/sockaddr.3type.html)
3. Размер передаваемой структуры из второго аргумента

##### Как проверить
Подключаемся к серверу любым TCP клиентом, например, nc. Указывает хост и порт где запущен наш сервер.
```
nc 127.0.0.1 8080
```
В консоли сервера увидим сообщение с номером файлового дескриптора из метода accept.
```
Accepted connection, fd = 4
```